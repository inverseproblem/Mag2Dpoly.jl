<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Mag2Dpoly.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Mag2Dpoly.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#User-guide"><span>User guide</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li><li><a class="tocitem" href="#Public-API"><span>Public API</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h1><ul><li><a href="#Contents">Contents</a></li><ul><li><a href="#User-guide">User guide</a></li><li><a href="#Documentation">Documentation</a></li><ul><li><a href="#Installation">Installation</a></li><li><a href="#Theoretical-Background">Theoretical Background</a></li><li><a href="#Tutorial">Tutorial</a></li></ul><li><a href="#Public-API">Public API</a></li><ul><li><a href="#Data-structures">Data structures</a></li><li><a href="#Forward-functions">Forward functions</a></li><ul><li><a href="#Single-polygonal-body">Single polygonal body</a></li><li><a href="#Multiple-polygonal-bodies">Multiple polygonal bodies</a></li><li><a href="#Forward-algorithms-alone">Forward algorithms alone</a></li></ul><li><a href="#Useful-functions">Useful functions</a></li></ul></ul></ul><h2 id="User-guide"><a class="docs-heading-anchor" href="#User-guide">User guide</a><a id="User-guide-1"></a><a class="docs-heading-anchor-permalink" href="#User-guide" title="Permalink"></a></h2><p><strong>Mag2Dpoly</strong> <em>is a Julia package conceived for forward magnetic anomaly calculation due to two-dimensional polygonal bodies with uniform arbitrary polarization</em>. </p><p>The formulations implemented in this package are that of Talwani &amp; Heirtzler (1962, 1964), Won &amp; Bevis (1987) and revised Kravchinsky et al. (2019).</p><p>If you use this code for research or else, please cite the related paper:</p><p>Alessandro Ghirotto, Andrea Zunino, Egidio Armadillo &amp; Klaus Mosegaard (2020). <strong>Magnetic Anomalies Caused by 2D Polygonal Structures with Uniform Arbitrary Polarization: new insights from analytical/numerical comparison among available algorithm formulations</strong>. Submitted to Geophysical Research Letters.</p><p>The specific procedures for each formulation, the analytical/numerical results derived from their comparison and the rectification made to Kravchinsky et al. (2019) algorithm are describde in detail in the paper above.</p><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><h3 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h3><p>To install the package simple enter into the package manager mode in Julia by typing &quot;<code>]</code>&quot; at the  REPL prompt and then use <code>add</code>, i.e.,</p><pre><code class="language-none">(v1.5) pkg&gt; add Mag2Dpoly</code></pre><p>The package will be automatically downloaded from the web and installed.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>At the moment the package is not yet registered in the official Julia registry, so,  to install it run the following in package mode:</p><pre><code class="language-julia">(v1.5) pkg&gt; add https://github.com/inverseproblem/Mag2Dpoly.jl</code></pre></div></div><p>Alternatively, use the path where the directory of the package is located, be it local or remote (Github):</p><pre><code class="language-none">(v1.5) pkg&gt; add /path/to/Mag2Dpoly.jl</code></pre><h3 id="Theoretical-Background"><a class="docs-heading-anchor" href="#Theoretical-Background">Theoretical Background</a><a id="Theoretical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Theoretical-Background" title="Permalink"></a></h3><p>For a theoretical explanation, let us consider a three-dimensional non-magnetic  space in which a body infinitely extended in the <span>$y$</span> direction is immersed. </p><p>The common aim of all formulations is the calculation of the magnetic field of  this body upon an observation point <span>$(x_0,z_0)$</span> located along a profile aligned to  the <span>$x$</span> direction (the positive <span>$z$</span> axis is assumed pointing downward).</p><p>The starting assumption is that our body can be considered as discretized by an  infinite number of uniformly-magnetized elementary volumes with infinitesimal dimensions <span>$dx$</span>, <span>$dy$</span>, <span>$dz$</span>.</p><p>Within this assumption, the magnetic field associated to the body can be mathematically  expressed in terms of a line integral around its periphery, represented in two dimensions  as its polygonal cross-section (in red). <img src="images/intro.svg" alt/></p><h3 id="Tutorial"><a class="docs-heading-anchor" href="#Tutorial">Tutorial</a><a id="Tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial" title="Permalink"></a></h3><p>First load the module and define some magnetization vectors,</p><pre><code class="language-julia">using Mag2Dpoly

# induced magnetization
Jind = MagnetizVector(mod=4.9,Ideg=90.0,Ddeg=45.0)
# remanent magnetization
Jrem = MagnetizVector(mod=3.1,Ideg=45.0,Ddeg=0.0)</code></pre><p>and then define some observation points </p><pre><code class="language-julia"># angle with the North axis
northxax = 90.0

# number of observatoin
N=101
xzobs = hcat(LinRange(0.0,100.0,N), -1.0*ones(N))</code></pre><p>Finally the general list of vertices of the poligonal bodies and the relative indices mapping each body to its vertices:</p><pre><code class="language-julia"># vertices of the poligonal bodies
vertices  = [35.0 50.0;
             65.0 50.0;
             80.0 35.0;
             65.0 20.0;
             35.0 20.0;
             20.0 35.0]

# indices of vertices for the body
ind1 = collect(1:6)
bodyindices = [ind1]
# construct the poligonal body object
pbody = MagPolygBodies2D(bodyindices,vertices)</code></pre><pre class="documenter-example-output">MagPolygBodies2D(BodySegments2D[BodySegments2D([35.0 50.0; 65.0 50.0; … ; 35.0 20.0; 20.0 35.0], [65.0 50.0; 80.0 35.0; … ; 20.0 35.0; 35.0 50.0], 6)], [35.0 50.0; 65.0 50.0; … ; 35.0 20.0; 20.0 35.0])</pre><p>At this point the total field can be computed. We select <code>&quot;talwani&quot;</code> as the forward type:</p><pre><code class="language-julia"># type of forward algorithm
forwardtype = &quot;talwani&quot;
# arrays of magnetization vectors
Jinds = [Jind]
Jrems = [Jrem]
# compute total field
tmag = tmagpolybodies2Dgen(xzobs,Jinds,Jrems,northxax,pbody,forwardtype)</code></pre><pre class="documenter-example-output">101-element Array{Float64,1}:
 -116.16336912423323
 -107.60475622349603
  -98.17723975959665
  -87.82662842366807
  -76.49775256996033
  -64.13484643609522
  -50.68200185889778
  -36.083699080365044
  -20.28541994999382
   -3.2343484367466506
    ⋮
  -20.28541994999403
  -36.083699080364866
  -50.68200185889757
  -64.13484643609497
  -76.49775256996033
  -87.8266284236681
  -98.1772397595965
 -107.60475622349612
 -116.16336912423299</pre><p>Now we can plot the results:</p><pre><code class="language-none">using PyPlot
xmi=minimum(xzobs[:,1]) 
xma=maximum(xzobs[:,1])
figure()
subplot(211)
plot(xzobs[:,1],tmag,&quot;.-&quot;) 
xlim(xmi,xma)
subplot(212)
x = [pbody.bo[1].ver1[:,1]...,pbody.bo[1].ver2[end,1]]
y = [pbody.bo[1].ver1[:,2]...,pbody.bo[1].ver2[end,2]]
plot(x,y,&quot;o-&quot;)
xlim(xmi,xma)
gca().invert_yaxis()</code></pre><p><img src="images/plotex1.svg" alt/></p><h2 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly" href="#Mag2Dpoly"><code>Mag2Dpoly</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Mag2Dpoly</p><p>A module to perform magnetic anomaly calculations for 2D polygonal bodies.</p><p><strong>Exports</strong></p><ul><li><a href="#Mag2Dpoly.BodySegments2D"><code>BodySegments2D</code></a></li><li><a href="#Mag2Dpoly.MagPolygBodies2D"><code>MagPolygBodies2D</code></a></li><li><a href="#Mag2Dpoly.MagnetizVector"><code>MagnetizVector</code></a></li><li><a href="#Mag2Dpoly.tmagpoly2D"><code>tmagpoly2D</code></a></li><li><a href="#Mag2Dpoly.tmagpoly2Dgen"><code>tmagpoly2Dgen</code></a></li><li><a href="#Mag2Dpoly.tmagpolybodies2D"><code>tmagpolybodies2D</code></a></li><li><a href="#Mag2Dpoly.tmagpolybodies2Dgen"><code>tmagpolybodies2Dgen</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/Mag2Dpoly.jl#L1-L9">source</a></section></article><h3 id="Data-structures"><a class="docs-heading-anchor" href="#Data-structures">Data structures</a><a id="Data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Data-structures" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.BodySegments2D" href="#Mag2Dpoly.BodySegments2D"><code>Mag2Dpoly.BodySegments2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct BodySegments2D</code></pre><p>Structure containing the segments of a polygonal body. To create an instance a set of indices have to be passed on.</p><p><strong>Fields</strong></p><ul><li><p><code>ver1::SubArray</code></p><p>(x,y) for first set of vertices (beginning of segments)</p></li><li><p><code>ver2::SubArray</code></p><p>(x,y) for second set of vertices (end of segments)</p></li><li><p><code>nsegm::Integer</code></p><p>total number of segments</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/magdatastruct.jl#L5">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Vertices of the polygonal bodies must be provided  counterclockwise to the function <code>BodySegments2D</code> to perform magnetic anomaly calculation using the functions in the next section <strong>Forward functions</strong></p></div></div><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.MagPolygBodies2D" href="#Mag2Dpoly.MagPolygBodies2D"><code>Mag2Dpoly.MagPolygBodies2D</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MagPolygBodies2D</code></pre><p>Structure containing a set of polygonal bodies described by their segments and all vertices. To create an instance, input an array of vectors of indices    (of vertices) for each body and the array of all the vertices.</p><p><strong>Fields</strong></p><ul><li><p><code>bo::Array{BodySegments2D,1}</code></p><p>array of bodies defined by their vertices</p></li><li><p><code>allvert::Array{var&quot;#s14&quot;,2} where var&quot;#s14&quot;&lt;:Real</code></p><p>array of all vertices for all bodies</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/magdatastruct.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.MagnetizVector" href="#Mag2Dpoly.MagnetizVector"><code>Mag2Dpoly.MagnetizVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MagnetizVector</code></pre><p>Structure containing the components of a magnetization vector,    i.e., module, inclination and declination angles.</p><p><strong>Fields</strong></p><ul><li><p><code>mod::Real</code></p><p>modulus</p></li><li><p><code>Ideg::Real</code></p><p>inclination in degrees</p></li><li><p><code>Ddeg::Real</code></p><p>declination in degrees</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0">source</a></section></article><h3 id="Forward-functions"><a class="docs-heading-anchor" href="#Forward-functions">Forward functions</a><a id="Forward-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-functions" title="Permalink"></a></h3><h4 id="Single-polygonal-body"><a class="docs-heading-anchor" href="#Single-polygonal-body">Single polygonal body</a><a id="Single-polygonal-body-1"></a><a class="docs-heading-anchor-permalink" href="#Single-polygonal-body" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagpolybodies2D" href="#Mag2Dpoly.tmagpolybodies2D"><code>Mag2Dpoly.tmagpolybodies2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagpolybodies2D(xzobs::Array{var&quot;#s16&quot;,2} where var&quot;#s16&quot;&lt;:Real, Jinds::Array{MagnetizVector,1}, Jrems::Array{MagnetizVector,1}, northxax::Real, bodies::MagPolygBodies2D) -&gt; Array{_A,1} where _A
</code></pre><p>Total magnetic field (2D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization.  Based on Talwani &amp; Heitzler (1964), the default algorithm in Mag2Dpoly package. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagpolybodies2Dgen" href="#Mag2Dpoly.tmagpolybodies2Dgen"><code>Mag2Dpoly.tmagpolybodies2Dgen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagpolybodies2Dgen(xzobs::Array{var&quot;#s16&quot;,2} where var&quot;#s16&quot;&lt;:Real, Jinds::Array{MagnetizVector,1}, Jrems::Array{MagnetizVector,1}, northxax::Real, bodies::MagPolygBodies2D, forwardtype::String) -&gt; Array{_A,1} where _A
</code></pre><p>Total magnetic field (2D) for a set of polygonal bodies defined by their corners. Takes into account both induced and remnant magnetization. Generic version containing four different algorithm formulations <code>forwardtype</code>, passed as a string:</p><ul><li>&quot;talwani&quot;      –&gt; Talwani &amp; Heitzler (1964)</li><li>&quot;talwani_red&quot;  –&gt; Talwani &amp; Heitzler (1964) rederived from Kravchinsky et al. 2019</li><li>&quot;krav&quot;         –&gt; Kravchinsky et al. (2019) rectified by Ghirotto et al. (2020)</li><li>&quot;wonbev&quot;       –&gt; Won &amp; Bevis (1987)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L23">source</a></section></article><h4 id="Multiple-polygonal-bodies"><a class="docs-heading-anchor" href="#Multiple-polygonal-bodies">Multiple polygonal bodies</a><a id="Multiple-polygonal-bodies-1"></a><a class="docs-heading-anchor-permalink" href="#Multiple-polygonal-bodies" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagpoly2D" href="#Mag2Dpoly.tmagpoly2D"><code>Mag2Dpoly.tmagpoly2D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagpoly2D(xzobs::Array{var&quot;#s23&quot;,2} where var&quot;#s23&quot;&lt;:Real, Jind::MagnetizVector, Jrem::MagnetizVector, northxax::Real, body::BodySegments2D) -&gt; Array{_A,1} where _A
</code></pre><p>Total magnetic field (2D) for a polygon defined by its corners. Takes into account both induced and remnant magnetization.  Based on Talwani &amp; Heitzler (1964), the default algorithm in Mag2Dpoly package. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagpoly2Dgen" href="#Mag2Dpoly.tmagpoly2Dgen"><code>Mag2Dpoly.tmagpoly2Dgen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagpoly2Dgen(xzobs::Array{var&quot;#s13&quot;,2} where var&quot;#s13&quot;&lt;:Real, Jind::MagnetizVector, Jrem::MagnetizVector, northxax::Real, body::BodySegments2D, forwardtype::String) -&gt; Array{_A,1} where _A
</code></pre><p>Total magnetic field (2D) for a polygon defined by its corners. Takes into account both induced and remnant magnetization. Generic version containing four different algorithm formulations <code>forwardtype</code>, passed as a string:</p><ul><li>&quot;talwani&quot;      –&gt; Talwani &amp; Heitzler (1964)</li><li>&quot;talwani_red&quot;  –&gt; Talwani &amp; Heitzler (1964) rederived from Kravchinsky et al. 2019</li><li>&quot;krav&quot;         –&gt; Kravchinsky et al. (2019) rectified by Ghirotto et al. (2020)</li><li>&quot;wonbev&quot;       –&gt; Won &amp; Bevis (1987)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L47">source</a></section></article><h4 id="Forward-algorithms-alone"><a class="docs-heading-anchor" href="#Forward-algorithms-alone">Forward algorithms alone</a><a id="Forward-algorithms-alone-1"></a><a class="docs-heading-anchor-permalink" href="#Forward-algorithms-alone" title="Permalink"></a></h4><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These functions are not exported. To call them  type <code>Mag2Dpoly.</code> before the name of the functions.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagtalwani" href="#Mag2Dpoly.tmagtalwani"><code>Mag2Dpoly.tmagtalwani</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagtalwani(x1::Real, z1::Real, x2::Real, z2::Real, Jx::Real, Jz::Real, Iind::Real, Dind::Real, C::Real) -&gt; Any
</code></pre><p>Total magnetic field (2D) for a line segment. Formulas from Talwani &amp; Heitzler (1964).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L274">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagtalwanired" href="#Mag2Dpoly.tmagtalwanired"><code>Mag2Dpoly.tmagtalwanired</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagtalwanired(x1::Real, z1::Real, x2::Real, z2::Real, Jx::Real, Jz::Real, Iind::Real, Dind::Real, C::Real) -&gt; Any
</code></pre><p>Total magnetic field (2D) for a ribbon. Talwani &amp; Heitzler (1964) modified by Kravchinsky et al. (2019).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L470-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagkrav" href="#Mag2Dpoly.tmagkrav"><code>Mag2Dpoly.tmagkrav</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagkrav(x1::Real, z1::Real, x2::Real, z2::Real, Jtotx::Real, Jtotz::Real, Iind::Real, Dind::Real, Cnorth::Real) -&gt; Any
</code></pre><p>Total magnetic field (2D) for a line segment. Formulas from Kravchinsky et al (2019) rectified by Ghirotto et al. (2021). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.tmagwonbev" href="#Mag2Dpoly.tmagwonbev"><code>Mag2Dpoly.tmagwonbev</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tmagwonbev(x1::Real, z1::Real, x2::Real, z2::Real, modJind::Real, modJrem::Real, Iind::Real, Dind::Real, Irem::Real, Drem::Real, C::Real) -&gt; Any
</code></pre><p>Total magnetic field (2D) for a line segment. Formulas from Won &amp; Bevis (1987).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L582-L587">source</a></section></article><h3 id="Useful-functions"><a class="docs-heading-anchor" href="#Useful-functions">Useful functions</a><a id="Useful-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-functions" title="Permalink"></a></h3><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>These functions are not exported. To call them type <code>Mag2Dpoly.</code> before the name of the functions.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.convert_H_to_B_nT" href="#Mag2Dpoly.convert_H_to_B_nT"><code>Mag2Dpoly.convert_H_to_B_nT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert_H_to_B_nT(H_Am::Real) -&gt; Any
</code></pre><p>Convert from the field H (A/m) to B (nT).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/magutils.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.convert_B_nT_to_H" href="#Mag2Dpoly.convert_B_nT_to_H"><code>Mag2Dpoly.convert_B_nT_to_H</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert_B_nT_to_H(B_nT::Real) -&gt; Any
</code></pre><p>Convert from the field B (nT) to H (A/m).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/magutils.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.magcomp" href="#Mag2Dpoly.magcomp"><code>Mag2Dpoly.magcomp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">magcomp(modJind::Real, Iind::Real, Dind::Real, modJrem::Real, Irem::Real, Drem::Real, C::Real) -&gt; Tuple{Any,Any,Any}
</code></pre><p>Vector addition of magnetic (remnant + induced) components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/magutils.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Mag2Dpoly.checkanticlockwiseorder" href="#Mag2Dpoly.checkanticlockwiseorder"><code>Mag2Dpoly.checkanticlockwiseorder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">checkanticlockwiseorder(body::BodySegments2D) -&gt; Bool
</code></pre><p>Check whether the polygonal body has segments ordered anticlockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/inverseproblem/Mag2Dpoly.jl/blob/378afcd32c79f4c4ffa8e656fae781551f90c4ef/src/mag2dpolybodies.jl#L219">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 18 February 2021 16:14">Thursday 18 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
